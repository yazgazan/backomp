package bacom

import (
	"bytes"
	"io"
	"math"
	"net/http"
	"os"
	"path/filepath"
)

// Saver is used to handle saving or requests and responses to a new version
type Saver struct {
	dir, fname, reqName string
}

// NewSaver returns a *Saver. `dir` is the output folder and `fname` is the name of the
// original request file
func NewSaver(dir, fname string) *Saver {
	return &Saver{
		dir:     dir,
		fname:   fname,
		reqName: filepath.Base(fname),
	}
}

// SaveRequest moves the request file to the new folder (as specified in NewSaver).
// The file name is adjusted if file with the same name already exists at that location
// and if the files are not identical.
func (s *Saver) SaveRequest() error {
	reqName, err := nameFromReqFileName(filepath.Base(s.fname))
	if err != nil {
		return err
	}
	dst := filepath.Join(s.dir, s.reqName)

	if !fileExists(dst) {
		return copyFile(s.fname, dst)
	}

	ok, err := compareFiles(s.fname, dst)
	if err != nil {
		return err
	}
	if ok {
		return nil
	}

	dst = ReqFileName(reqName, s.dir)
	s.reqName = filepath.Base(dst)

	return copyFile(s.fname, dst)
}

// SaveResponse saves the response to the appropriate file in the output
// directory. The name generated by SaveRequest is used to ensure the response
// has a matching file name.
func (s *Saver) SaveResponse(resp *http.Response) error {
	respName, err := GetResponseFilename(s.reqName)
	if err != nil {
		return err
	}

	f, err := os.Create(filepath.Join(s.dir, respName))
	if err != nil {
		return err
	}
	defer handleClose(&err, f)

	return resp.Write(f)
}

func fileExists(fname string) bool {
	_, err := os.Stat(fname)

	return !os.IsNotExist(err)
}

func compareFiles(lhsFname, rhsFname string) (identical bool, err error) {
	lhsF, err := os.Open(lhsFname)
	if err != nil {
		return false, err
	}
	defer handleClose(&err, lhsF)
	rhsF, err := os.Open(rhsFname)
	if err != nil {
		return false, err
	}
	defer handleClose(&err, rhsF)

	return compareReaders(lhsF, rhsF)
}

func copyFile(srcFname, dstFname string) (err error) {
	src, err := os.Open(srcFname)
	if err != nil {
		return err
	}
	defer handleClose(&err, src)

	dst, err := os.Create(dstFname)
	if err != nil {
		return err
	}
	defer handleClose(&err, dst)

	_, err = io.Copy(dst, src)

	return err
}

func handleClose(err *error, closer io.Closer) {
	errClose := closer.Close()
	if *err == nil {
		*err = errClose
	}
}

func compareReaders(lhs, rhs io.Reader) (bool, error) {
	var lhsN, rhsN, n int
	var lhsErr, rhsErr error
	lhsB := make([]byte, 4096)
	rhsB := make([]byte, 4096)

	for {
		n, lhsErr = lhs.Read(lhsB[lhsN:])
		if lhsErr != nil && lhsErr != io.EOF {
			return false, lhsErr
		}
		lhsN += n
		n, rhsErr = rhs.Read(rhsB[rhsN:])
		if rhsErr != nil && rhsErr != io.EOF {
			return false, rhsErr
		}
		rhsN += n
		n = minInt(lhsN, rhsN)

		if !bytes.Equal(lhsB[:n], rhsB[:n]) {
			return false, nil
		}

		if lhsErr == io.EOF || rhsErr == io.EOF {
			return lhsErr == rhsErr, nil
		}
		copy(lhsB, lhsB[n:])
		lhsN -= n
		copy(rhsB, rhsB[n:])
		rhsN -= n
	}
}

func minInt(vals ...int) int {
	min := math.MaxInt64

	for _, v := range vals {
		if v < min {
			min = v
		}
	}

	return min
}
